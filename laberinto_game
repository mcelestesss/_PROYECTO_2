import pygame
import random
import time
import json
import os
from collections import deque
import math

# ================== CONFIGURACI√ìN AUTOM√ÅTICA DE RUTAS ==================
def configurar_rutas():
    """
    Configura autom√°ticamente las rutas para que funcione en cualquier computadora
    Busca la carpeta 'sonidos' en diferentes ubicaciones posibles
    """
    print(" Configurando rutas autom√°ticamente...")
    
    # Obtener la ruta donde est√° este archivo Python
    ruta_script = os.path.dirname(os.path.abspath(__file__))
    
    # Rutas posibles donde buscar la carpeta 'sonidos'
    rutas_posibles = [
        ruta_script,  # Donde est√° el script
        os.getcwd(),  # Directorio actual de trabajo
        os.path.join(ruta_script, '_PROYECTO_2'),  # Si est√° dentro de _PROYECTO_2
        ruta_script  # Misma carpeta
    ]
    
    # Buscar la carpeta 'sonidos'
    for ruta_base in rutas_posibles:
        ruta_sonidos = os.path.join(ruta_base, 'sonidos')
        if os.path.exists(ruta_sonidos) and os.path.isdir(ruta_sonidos):
            print(f" Carpeta 'sonidos' encontrada en: {ruta_sonidos}")
            
            # Verificar archivos de audio
            archivos_audio = os.listdir(ruta_sonidos)
            print(f" Archivos de audio encontrados: {archivos_audio}")
            
            # Cambiar al directorio correcto
            os.chdir(ruta_base)
            print(f" Directorio de trabajo establecido: {ruta_base}")
            return True
    
    print(" No se encontr√≥ la carpeta 'sonidos'")
    print(" Aseg√∫rate de que la carpeta 'sonidos' est√© en la misma carpeta que laberinto.py")
    return False

# Ejecutar configuraci√≥n autom√°tica
configuracion_exitosa = configurar_rutas()
print(f" Directorio final: {os.getcwd()}")

# ================== INICIALIZACI√ìN ==================
pygame.init()

# Constantes del juego
ANCHO_MAPA = 21
ALTO_MAPA = 21
TAMANO_CELDA = 30
ANCHO_VENTANA = ANCHO_MAPA * TAMANO_CELDA
ALTO_VENTANA = ALTO_MAPA * TAMANO_CELDA + 100
FPS = 60

# Colores
NEGRO = (0, 0, 0)
BLANCO = (255, 255, 255)
GRIS = (128, 128, 128)
VERDE_CAMINO = (46, 204, 113)
AZUL_MURO = (52, 73, 94)
MORADO_TUNEL = (155, 89, 182)
AMARILLO_LIANA = (241, 196, 15)
ROJO_JUGADOR = (231, 76, 60)
AZUL_ENEMIGO = (52, 152, 219)
VERDE_ENERGIA = (39, 174, 96)
ROJO_ENERGIA = (192, 57, 43)
NARANJA_TRAMPA = (230, 126, 34)

# ================== CLASES B√ÅSICAS ==================
# (Mant√©n todas tus clases Casilla, Mapa, Entidad, Jugador, Enemigo, Trampa igual que antes)
class Casilla:
    def __init__(self, x, y):
        self.x = x
        self.y = y
        
    def transitable_por_jugador(self): 
        return False
        
    def transitable_por_enemigo(self): 
        return False

class Camino(Casilla):
    def transitable_por_jugador(self): 
        return True
        
    def transitable_por_enemigo(self): 
        return True

class Muro(Casilla):
    def transitable_por_jugador(self): 
        return False
        
    def transitable_por_enemigo(self): 
        return False

class Liana(Casilla):
    def transitable_por_jugador(self): 
        return False
        
    def transitable_por_enemigo(self): 
        return True

class Tunel(Casilla):
    def transitable_por_jugador(self): 
        return True
        
    def transitable_por_enemigo(self): 
        return False

class Mapa:
    def __init__(self, ancho, alto):
        self.ancho = ancho
        self.alto = alto
        self.matriz = [[1 for _ in range(ancho)] for _ in range(alto)]
        self.objetos = None

    def generar_laberinto(self):
        def dfs(x, y):
            direcciones = [(2, 0), (-2, 0), (0, 2), (0, -2)]
            random.shuffle(direcciones)
            for dx, dy in direcciones:
                nx, ny = x + dx, y + dy
                if 1 <= nx < self.alto - 1 and 1 <= ny < self.ancho - 1:
                    if self.matriz[nx][ny] == 1:
                        self.matriz[nx][ny] = 0
                        self.matriz[x + dx // 2][y + dy // 2] = 0
                        dfs(nx, ny)
                        
        self.matriz = [[1 for _ in range(self.ancho)] for _ in range(self.alto)]
        self.matriz[1][1] = 0
        dfs(1, 1)
        self.matriz[self.alto - 2][self.ancho - 2] = 0
        self._agregar_elementos_especiales()

    def _agregar_elementos_especiales(self):
        for _ in range(self.ancho * self.alto // 20):
            x, y = random.randint(1, self.alto-2), random.randint(1, self.ancho-2)
            if self.matriz[x][y] == 0:
                if random.random() < 0.5:
                    self.matriz[x][y] = 2  # Liana
                else:
                    self.matriz[x][y] = 3  # T√∫nel

    def existe_camino(self, inicio, fin):
        queue = deque([inicio])
        visitado = set([inicio])
        while queue:
            x, y = queue.popleft()
            if (x, y) == fin: 
                return True
            for dx, dy in [(1, 0), (0, 1), (-1, 0), (0, -1)]:
                nx, ny = x + dx, y + dy
                if 0 <= nx < self.alto and 0 <= ny < self.ancho:
                    if self.matriz[nx][ny] == 0 and (nx, ny) not in visitado:
                        visitado.add((nx, ny))
                        queue.append((nx, ny))
        return False

    def convertir_a_objetos(self):
        objetos = []
        for x in range(self.alto):
            fila = []
            for y in range(self.ancho):
                valor = self.matriz[x][y]
                if valor == 0: 
                    fila.append(Camino(x, y))
                elif valor == 1: 
                    fila.append(Muro(x, y))
                elif valor == 2: 
                    fila.append(Liana(x, y))
                elif valor == 3: 
                    fila.append(Tunel(x, y))
                else:
                    fila.append(Muro(x, y))
            objetos.append(fila)
        self.objetos = objetos
        return objetos

    def _es_transitable_numero(self, x, y, es_jugador=True):
        v = self.matriz[x][y]
        if v == 0:  # Camino
            return True
        if v == 1:  # Muro
            return False
        if v == 2:  # Liana -> solo enemigo
            if not es_jugador:
                return True  # Enemigos siempre s√≠
        else:
            # Para jugador, depende del modo (se maneja en mover_jugador)
            return False  # Por defecto no, pero se sobreescribe en la l√≥gica del juego
        if v == 3:  # T√∫nel -> solo jugador
            return es_jugador
        return False

    def bfs_camino(self, inicio, fin, es_jugador=True):
        if inicio == fin:
            return [inicio]
        queue = deque([inicio])
        padres = {inicio: None}
        while queue:
            nodo = queue.popleft()
            if nodo == fin:
                path = []
                cur = fin
                while cur is not None:
                    path.append(cur)
                    cur = padres[cur]
                path.reverse()
                return path
            x, y = nodo
            for dx, dy in [(1,0),(0,1),(-1,0),(0,-1)]:
                nx, ny = x+dx, y+dy
                if 0 <= nx < self.alto and 0 <= ny < self.ancho and (nx,ny) not in padres:
                    if self._es_transitable_numero(nx, ny, es_jugador):
                        padres[(nx,ny)] = nodo
                        queue.append((nx,ny))
        return None

class Entidad:
    def __init__(self, x, y):
        self.x = x
        self.y = y
        
    def mover(self, nx, ny):
        self.x = nx
        self.y = ny

class Jugador(Entidad):
    def __init__(self, x, y):
        super().__init__(x, y)
        self.energia = 100
        self.trampas = 3
        self.corriendo = False

class Enemigo(Entidad):
    def __init__(self, x, y):
        super().__init__(x, y)
        self.vivo = True

class Trampa:
    def __init__(self, x, y):
        self.x = x
        self.y = y
        self.tiempo_colocacion = time.time()
        self.activa = True
        self.tiempo_activacion = time.time()

    def verificar_tiempo_vida(self):
        return time.time() - self.tiempo_activacion < 30

# ================== SISTEMA DE SONIDO CORREGIDO ==================
# ================== SISTEMA DE SONIDO CORREGIDO ==================

class SistemaSonido:
    def __init__(self):
        try:
            pygame.mixer.init(frequency=22050, size=-16, channels=2, buffer=512)
            self.sonidos = {}
            self.musica_actual = None
            self.cargar_sonidos()
            print(" Sistema de sonido inicializado correctamente")
        except Exception as e:
            print(f"  No se pudo inicializar el sistema de sonido: {e}")
            self.sonidos = None
    
    def obtener_ruta_sonido(self, archivo):
        """Busca el archivo de sonido en diferentes ubicaciones"""
        rutas_posibles = [
            os.path.join('sonidos', archivo),
            os.path.join(os.getcwd(), 'sonidos', archivo),
            archivo  # Ruta directa
]
        
        for ruta in rutas_posibles:
            if os.path.exists(ruta):
                print(f"Encontrado: {ruta}")
                return ruta
            else:
                print(f" No encontrado: {ruta}")
        
        return None
    
    def cargar_sonidos(self):
        """Carga los archivos de sonido REALES"""
        try:
            # ARCHIVOS REALES QUE TIENES
            archivos_reales = {
                'menu_principal': 'SuperHero_original.ogg',
                'modo_escape': 'computer_world.mp3', 
                'modo_cazador': 'creepy_piano.mp3'
            }
            
            print(" Cargando archivos de sonido...")
            
            for nombre, archivo in archivos_reales.items():
                ruta = self.obtener_ruta_sonido(archivo)
                if ruta:
                    try:
                        # Para m√∫sica usamos pygame.mixer.music
                        if nombre in ['menu_principal', 'modo_escape', 'modo_cazador']:
                            # Solo verificamos que existe, no cargamos como Sound
                            self.sonidos[nombre] = ruta
                            print(f" M√∫sica lista: {archivo}")
                        else:
                            self.sonidos[nombre] = pygame.mixer.Sound(ruta)
                            print(f" Sonido cargado: {archivo}")
                    except Exception as e:
                        print(f"‚ö†Ô∏è  Error cargando {archivo}: {e}")
                        self.crear_sonido_temporal(nombre)
                else:
                    print(f"üìÅ Archivo no encontrado en ninguna ubicaci√≥n: {archivo}")
                    self.crear_sonido_temporal(nombre)
                    
            # Crear efectos de sonido temporales
            efectos = ['movimiento', 'trampa', 'victoria', 'derrota', 'enemigo_atrapado']
            for efecto in efectos:
                if efecto not in self.sonidos:
                    self.crear_sonido_temporal(efecto)
                    
        except Exception as e:
            print(f" Error en carga de sonidos: {e}")
            self.crear_sonidos_temporales()
    
    def crear_sonido_temporal(self, nombre):
        """Crea sonido temporal"""
        try:
            sample_rate = 22050
            frames = 1000
            
            sound_data = bytearray()
            for i in range(frames):
                t = i / sample_rate
                if nombre == 'movimiento':
                    freq = 300
                elif nombre == 'trampa':
                    freq = 200
                elif nombre == 'victoria':
                    freq = 600
                elif nombre == 'derrota':
                    freq = 150
                else:
                    freq = 440
                    
                valor = int(127 + 127 * math.sin(2.0 * math.pi * freq * t))
                sound_data.append(min(255, max(0, valor)))
            
            self.sonidos[nombre] = pygame.mixer.Sound(buffer=bytes(sound_data))
            print(f" Sonido temporal creado: {nombre}")
            
        except Exception as e:
            print(f"  Error creando sonido temporal: {e}")
            self.sonidos[nombre] = pygame.mixer.Sound(buffer=bytes([128] * 1000))
    
    def crear_sonidos_temporales(self):
        """Crea todos los sonidos temporales"""
        sonidos_necesarios = ['menu_principal', 'modo_escape', 'modo_cazador', 
                             'movimiento', 'trampa', 'victoria', 'derrota', 'enemigo_atrapado']
        for nombre in sonidos_necesarios:
            self.crear_sonido_temporal(nombre)
    
    def reproducir_musica(self, nombre, volumen=0.5, loop=True):
        """Reproduce m√∫sica usando pygame.mixer.music"""
        try:
            if nombre in self.sonidos:
                ruta = self.sonidos[nombre]
                if isinstance(ruta, str) and os.path.exists(ruta):
                    pygame.mixer.music.load(ruta)
                    if loop:
                        pygame.mixer.music.play(-1)
                    else:
                        pygame.mixer.music.play(1)
                    pygame.mixer.music.set_volume(volumen)
                    self.musica_actual = nombre
                    print(f"üéµ Reproduciendo m√∫sica: {nombre}")
                    return True
                else:
                    print(f" Ruta no v√°lida para {nombre}: {ruta}")
            else:
                print(f" M√∫sica {nombre} no encontrada en sonidos")
            return False
        except Exception as e:
            print(f"  Error reproduciendo m√∫sica {nombre}: {e}")
            return False
    
    def reproducir_efecto(self, nombre, volumen=0.7):
        """Reproduce efectos de sonido"""
        if self.sonidos and nombre in self.sonidos:
            try:
                # Si es un efecto (no m√∫sica), reproducir como Sound
                if nombre not in ['menu_principal', 'modo_escape', 'modo_cazador']:
                    self.sonidos[nombre].set_volume(volumen)
                    self.sonidos[nombre].play()
                else:
                    print(f" {nombre} es m√∫sica, no efecto")
            except Exception as e:
                print(f"  Error reproduciendo efecto {nombre}: {e}")
        else:
            print(f" Efecto {nombre} no disponible")
    
    def detener_musica(self):
        """Detiene la m√∫sica actual"""
        try:
            pygame.mixer.music.stop()
            self.musica_actual = None
            print("  M√∫sica detenida")
        except Exception as e:
            print(f"  Error deteniendo m√∫sica: {e}")
    
    def detener_todo(self):
        """Detiene todos los sonidos"""
        try:
            pygame.mixer.music.stop()
            pygame.mixer.stop()
        except:
            pass
# ================== SISTEMA DE PUNTAJES ==================
class SistemaPuntajes:
    def __init__(self, archivo="puntajes.json"):
        self.archivo = archivo
        self.puntajes_escape = []
        self.puntajes_cazador = []
        self.cargar_puntajes()
    
    def cargar_puntajes(self):
        try:
            if os.path.exists(self.archivo):
                with open(self.archivo, 'r', encoding='utf-8') as f:
                    datos = json.load(f)
                    self.puntajes_escape = datos.get('escape', [])
                    self.puntajes_cazador = datos.get('cazador', [])
        except:
            self.puntajes_escape = []
            self.puntajes_cazador = []
    
    def guardar_puntajes(self):
        try:
            with open(self.archivo, 'w', encoding='utf-8') as f:
                json.dump({
                    'escape': self.puntajes_escape,
                    'cazador': self.puntajes_cazador
                }, f, indent=2, ensure_ascii=False)
        except:
            pass
    
    def agregar_puntaje(self, nombre, puntos, modo):
        if not nombre or not nombre.strip():
            nombre = "Jugador"
        
        nuevo_puntaje = {
            'nombre': nombre.strip(),
            'puntos': int(puntos),
            'fecha': time.strftime("%Y-%m-%d %H:%M:%S")
        }
        
        if modo == "ESCAPA":
            self.puntajes_escape.append(nuevo_puntaje)
            self.puntajes_escape.sort(key=lambda x: x['puntos'], reverse=True)
            self.puntajes_escape = self.puntajes_escape[:5]
        else:
            self.puntajes_cazador.append(nuevo_puntaje)
            self.puntajes_cazador.sort(key=lambda x: x['puntos'], reverse=True)
            self.puntajes_cazador = self.puntajes_cazador[:5]
        
        self.guardar_puntajes()
        return nuevo_puntaje
    
    def obtener_top_5(self, modo):
        return self.puntajes_escape if modo == "ESCAPA" else self.puntajes_cazador

# ================== CLASE JUEGO PRINCIPAL ==================
class Juego:
    def __init__(self, ancho=ANCHO_MAPA, alto=ALTO_MAPA, num_enemigos=3):
        self.mapa = Mapa(ancho, alto)
        self.jugador = None
        self.enemigos = []
        self.trampas = []
        self.nombre_jugador = ""
        self.modo_juego = ""
        self.num_enemigos = num_enemigos
        
        # Sistema de puntuaci√≥n
        self.puntos = 0
        self.tiempo_inicio = 0
        self.enemigos_atrapados = 0
        self.enemigos_escapados = 0
        self.ultima_trampa_tiempo = 0
        
        # Sistemas
        self.sonido = SistemaSonido()
        self.puntajes = SistemaPuntajes()
        self.juego_activo = False
        
        # Control de tiempo para enemigos
        self.ultimo_movimiento_enemigos = 0
        self.intervalo_movimiento = 500

    def reiniciar_estado(self):
        self.puntos = 0
        self.tiempo_inicio = 0
        self.enemigos_atrapados = 0
        self.enemigos_escapados = 0
        self.ultima_trampa_tiempo = 0
        self.trampas = []
        self.juego_activo = False
        self.ultimo_movimiento_enemigos = 0

    def iniciar(self, nombre, modo):
        self.reiniciar_estado()
    
        self.nombre_jugador = nombre.strip() if nombre.strip() else "Jugador"
        self.modo_juego = modo
        self.juego_activo = True
        self.tiempo_inicio = time.time()
        self.ultimo_movimiento_enemigos = pygame.time.get_ticks()

    # Reproducir m√∫sica del modo correspondiente
        print(f"üéÆ Iniciando juego - Modo: {modo}")  # ‚Üê AGREGA ESTA L√çNEA
        if modo == "ESCAPA":
            self.sonido.reproducir_musica('modo_escape', volumen=0.5)
        else:
            self.sonido.reproducir_musica('modo_cazador', volumen=0.5)
        
        inicio = (1, 1)
        salida = (self.mapa.alto - 2, self.mapa.ancho - 2)
        
        # Generar laberinto v√°lido
        self.mapa.generar_laberinto()
        while not self.mapa.existe_camino(inicio, salida):
            self.mapa.generar_laberinto()

        self.mapa.convertir_a_objetos()
        self.jugador = Jugador(*inicio)

        # Generar enemigos
        self.enemigos = []
        posibles = []
        for x in range(self.mapa.alto):
            for y in range(self.mapa.ancho):
                if self.mapa._es_transitable_numero(x, y, es_jugador=False):
                    if abs(x - inicio[0]) + abs(y - inicio[1]) > 6 and (x,y) != salida:
                        posibles.append((x,y))
        random.shuffle(posibles)
        
        i = 0
        while len(self.enemigos) < self.num_enemigos and i < len(posibles):
            pos = posibles[i]
            self.enemigos.append(Enemigo(*pos))
            i += 1
            
        if len(self.enemigos) == 0:
            self.enemigos.append(Enemigo(*salida))

    def actualizar_enemigos(self):
        if not self.juego_activo:
            return
            
        jugador_pos = (self.jugador.x, self.jugador.y)
        salida = (self.mapa.alto - 2, self.mapa.ancho - 2)

        for enemigo in self.enemigos:
            if (enemigo.x, enemigo.y) == jugador_pos:
                continue

            if self.modo_juego == "ESCAPA":
                # Enemigos persiguen al jugador
                inicio = (enemigo.x, enemigo.y)
                path = self.mapa.bfs_camino(inicio, jugador_pos, es_jugador=False)
                if path and len(path) >= 2:
                    siguiente = path[1]
                    enemigo.mover(*siguiente)
                else:
                    self._mover_enemigo_aleatorio(enemigo)
            else:
                # Enemigos huyen hacia la salida
                inicio = (enemigo.x, enemigo.y)
                path = self.mapa.bfs_camino(inicio, salida, es_jugador=False)
                if path and len(path) >= 2:
                    siguiente = path[1]
                    enemigo.mover(*siguiente)
                else:
                    self._mover_enemigo_aleatorio(enemigo)

    def _mover_enemigo_aleatorio(self, enemigo):
        opciones = []
        for dx, dy in [(1,0),(0,1),(-1,0),(0,-1)]:
            nx, ny = enemigo.x + dx, enemigo.y + dy
            if 0 <= nx < self.mapa.alto and 0 <= ny < self.mapa.ancho:
                if self.mapa._es_transitable_numero(nx, ny, es_jugador=False):
                    opciones.append((nx, ny))
        if opciones:
            enemigo.mover(*random.choice(opciones))

    def mover_jugador(self, dx, dy):
        if not self.juego_activo:
            return False
            
        nx = self.jugador.x + dx
        ny = self.jugador.y + dy
        
        if 0 <= nx < self.mapa.alto and 0 <= ny < self.mapa.ancho:
            casilla = self.mapa.objetos[nx][ny]

            if self.modo_juego == "ESCAPA":
            # En modo ESCAPA puede pasar por caminos, lianas Y t√∫neles
                transitable = (isinstance(casilla, Camino) or isinstance(casilla, Liana) or isinstance(casilla, Tunel))
            else:
            # En modo CAZADOR solo puede pasar por caminos
                transitable = isinstance(casilla, Camino)
        
            if transitable:
            # Consumo de energ√≠a
                costo_energia = 2 if self.jugador.corriendo else 1
                if self.jugador.energia >= costo_energia:
                    self.jugador.energia -= costo_energia
                    self.jugador.mover(nx, ny)
                    self.sonido.reproducir_efecto('movimiento')
                    return True
        return False

    def colocar_trampa(self):
        if not self.juego_activo or self.modo_juego != "ESCAPA":
            return False, "Solo en modo ESCAPA"
            
        tiempo_actual = time.time()
        
        if len(self.trampas) >= 3:
            return False, "M√°ximo 3 trampas activas"
            
        if tiempo_actual - self.ultima_trampa_tiempo < 5:
            tiempo_restante = 5 - (tiempo_actual - self.ultima_trampa_tiempo)
            return False, f"Espera {tiempo_restante:.1f}s"
        
        nueva_trampa = Trampa(self.jugador.x, self.jugador.y)
        self.trampas.append(nueva_trampa)
        self.ultima_trampa_tiempo = tiempo_actual
        self.sonido.reproducir_efecto('trampa')
        return True, "Trampa colocada"

    def verificar_trampas(self):
        trampas_a_eliminar = []
        enemigos_a_eliminar = []
        
        for trampa in self.trampas:
            for enemigo in self.enemigos:
                if trampa.activa and trampa.x == enemigo.x and trampa.y == enemigo.y:
                    trampas_a_eliminar.append(trampa)
                    enemigos_a_eliminar.append(enemigo)
                    
                    bonus = 25
                    self.puntos += bonus
                    self.enemigos_atrapados += 1
                    self.sonido.reproducir_efecto('trampa')
                    break
        
        for trampa in trampas_a_eliminar:
            self.trampas.remove(trampa)
        
        for enemigo in enemigos_a_eliminar:
            self.enemigos.remove(enemigo)
            self._respawn_enemigo(enemigo)
        
        return len(enemigos_a_eliminar) > 0

    def _respawn_enemigo(self, enemigo):
        opciones = []
        salida = (self.mapa.alto - 2, self.mapa.ancho - 2)
        
        for x in range(self.mapa.alto):
            for y in range(self.mapa.ancho):
                if self.mapa._es_transitable_numero(x, y, es_jugador=False):
                    if (x, y) != (self.jugador.x, self.jugador.y) and (x, y) != salida:
                        opciones.append((x, y))
        
        if opciones:
            nueva_pos = random.choice(opciones)
            enemigo.mover(nueva_pos[0], nueva_pos[1])
            self.enemigos.append(enemigo)

    def calcular_puntos_escape(self):
        tiempo_fin = time.time()
        tiempo_transcurrido = tiempo_fin - self.tiempo_inicio
        
        puntos_base = 1000
        penalizacion_tiempo = int(tiempo_transcurrido * 2)
        bonus_dificultad = self.num_enemigos * 50
        
        puntos_finales = max(100, puntos_base - penalizacion_tiempo + bonus_dificultad)
        self.puntos = puntos_finales
        
        self.puntajes.agregar_puntaje(self.nombre_jugador, puntos_finales, "ESCAPA")
        self.sonido.reproducir_efecto('victoria')
        
        return puntos_finales

    def cazar_enemigo(self, enemigo):
        self.enemigos_atrapados += 1
        puntos_ganados = 20 * self.num_enemigos
        self.puntos += puntos_ganados
        
        self.sonido.reproducir_efecto('enemigo_atrapado')
        return puntos_ganados

    def enemigo_escapa(self, enemigo):
        self.enemigos_escapados += 1
        puntos_perdidos = 10 * self.num_enemigos
        self.puntos = max(0, self.puntos - puntos_perdidos)
        return puntos_perdidos

    def verificar_estado_juego(self):
        if not self.juego_activo:
            return "continuar", self.puntos
            
        salida = (self.mapa.alto - 2, self.mapa.ancho - 2)
        jugador_pos = (self.jugador.x, self.jugador.y)
        
        if self.modo_juego == "ESCAPA" and jugador_pos == salida:
            puntos = self.calcular_puntos_escape()
            self.juego_activo = False
            return "victoria", puntos
        
        elif self.modo_juego == "CAZADOR" and self.enemigos_atrapados >= 10:
            self.puntajes.agregar_puntaje(self.nombre_jugador, self.puntos, "CAZADOR")
            self.sonido.reproducir_efecto('victoria')
            self.juego_activo = False
            return "victoria", self.puntos
        
        for e in self.enemigos:
            if (e.x, e.y) == jugador_pos:
                if self.modo_juego == "ESCAPA":
                    self.sonido.reproducir_efecto('derrota')
                    self.juego_activo = False
                    return "derrota", self.puntos
                elif self.modo_juego == "CAZADOR":
                    self.cazar_enemigo(e)
                    self._respawn_enemigo(e)
                    return "continuar", self.puntos
        
        if self.modo_juego == "CAZADOR":
            for e in self.enemigos:
                if (e.x, e.y) == salida:
                    self.enemigo_escapa(e)
                    self._respawn_enemigo(e)
        
        return "continuar", self.puntos

    def actualizar_energia(self):
        if self.juego_activo and self.jugador.energia < 100:
            self.jugador.energia = min(100, self.jugador.energia + 0.5)

# ================== INTERFAZ DE USUARIO ==================

class VentanaPuntajes:
    def __init__(self, pantalla, sistema_puntajes):
        self.pantalla = pantalla
        self.sistema_puntajes = sistema_puntajes
        self.font = pygame.font.Font(None, 36)
        self.font_chica = pygame.font.Font(None, 24)
        self.corriendo = True
    
    def ejecutar(self):
        while self.corriendo:
            for evento in pygame.event.get():
                if evento.type == pygame.QUIT:
                    self.corriendo = False
                elif evento.type == pygame.KEYDOWN:
                    if evento.key == pygame.K_ESCAPE or evento.key == pygame.K_RETURN:
                        self.corriendo = False
                elif evento.type == pygame.MOUSEBUTTONDOWN:
                    self.corriendo = False
            
            self.dibujar()
            pygame.display.flip()
    
    def dibujar(self):
        self.pantalla.fill(NEGRO)
        
        titulo = self.font.render("TOP 5 PUNTAJES", True, BLANCO)
        self.pantalla.blit(titulo, (ANCHO_VENTANA//2 - titulo.get_width()//2, 50))
        
        escape_titulo = self.font_chica.render("MODO ESCAPA", True, VERDE_CAMINO)
        self.pantalla.blit(escape_titulo, (100, 120))
        
        escape_puntajes = self.sistema_puntajes.obtener_top_5("ESCAPA")
        for i, puntaje in enumerate(escape_puntajes):
            texto = f"{i+1}. {puntaje['nombre']}: {puntaje['puntos']} pts"
            texto_surface = self.font_chica.render(texto, True, BLANCO)
            self.pantalla.blit(texto_surface, (100, 160 + i * 30))
        
        cazador_titulo = self.font_chica.render("MODO CAZADOR", True, ROJO_JUGADOR)
        self.pantalla.blit(cazador_titulo, (400, 120))
        
        cazador_puntajes = self.sistema_puntajes.obtener_top_5("CAZADOR")
        for i, puntaje in enumerate(cazador_puntajes):
            texto = f"{i+1}. {puntaje['nombre']}: {puntaje['puntos']} pts"
            texto_surface = self.font_chica.render(texto, True, BLANCO)
            self.pantalla.blit(texto_surface, (400, 160 + i * 30))
        
        instrucciones = self.font_chica.render("Presiona ESC, ENTER o haz clic para volver", True, BLANCO)
        self.pantalla.blit(instrucciones, (ANCHO_VENTANA//2 - instrucciones.get_width()//2, 350))

class AppPygame:
    def __init__(self):
        self.ventana = pygame.display.set_mode((ANCHO_VENTANA, ALTO_VENTANA))
        pygame.display.set_caption("Laberinto - POO")
        self.reloj = pygame.time.Clock()
        
        self.juego = Juego(ANCHO_MAPA, ALTO_MAPA, num_enemigos=4)
        
        self.corriendo = True
        self.estado = "registro"
        self.nombre_input = ""
        self.modo_seleccionado = "ESCAPA"
        
        self.font = pygame.font.Font(None, 36)
        self.font_chica = pygame.font.Font(None, 24)
        self.mensaje_temporal = ""
        self.tiempo_mensaje = 0

        # Reproducir m√∫sica del men√∫ al iniciar
        self.juego.sonido.reproducir_musica('menu_principal', volumen=0.5)

    def mostrar_pantalla_registro(self):
        self.ventana.fill(NEGRO)
        
        titulo = self.font.render("REGISTRO DE JUGADOR", True, BLANCO)
        self.ventana.blit(titulo, (ANCHO_VENTANA//2 - titulo.get_width()//2, 50))
        
        texto_nombre = self.font_chica.render("Nombre del jugador:", True, BLANCO)
        self.ventana.blit(texto_nombre, (ANCHO_VENTANA//2 - 150, 150))
        
        input_rect = pygame.Rect(ANCHO_VENTANA//2 - 150, 180, 300, 40)
        pygame.draw.rect(self.ventana, BLANCO, input_rect, 2)
        
        nombre_texto = self.font_chica.render(self.nombre_input, True, BLANCO)
        self.ventana.blit(nombre_texto, (input_rect.x + 5, input_rect.y + 10))
        
        if int(time.time() * 2) % 2 == 0:
            cursor_x = input_rect.x + 5 + nombre_texto.get_width()
            pygame.draw.line(self.ventana, BLANCO, 
                           (cursor_x, input_rect.y + 5),
                           (cursor_x, input_rect.y + 35), 2)
        
        texto_modo = self.font_chica.render("Modo de juego:", True, BLANCO)
        self.ventana.blit(texto_modo, (ANCHO_VENTANA//2 - 150, 250))
        
        color_escape = VERDE_CAMINO if self.modo_seleccionado == "ESCAPA" else GRIS
        color_cazador = ROJO_JUGADOR if self.modo_seleccionado == "CAZADOR" else GRIS
        
        escape_rect = pygame.Rect(ANCHO_VENTANA//2 - 150, 290, 140, 40)
        cazador_rect = pygame.Rect(ANCHO_VENTANA//2 + 10, 290, 140, 40)
        
        pygame.draw.rect(self.ventana, color_escape, escape_rect)
        pygame.draw.rect(self.ventana, color_cazador, cazador_rect)
        
        texto_escape = self.font_chica.render("ESCAPA", True, BLANCO)
        texto_cazador = self.font_chica.render("CAZADOR", True, BLANCO)
        
        self.ventana.blit(texto_escape, (escape_rect.centerx - texto_escape.get_width()//2, 
                                       escape_rect.centery - texto_escape.get_height()//2))
        self.ventana.blit(texto_cazador, (cazador_rect.centerx - texto_cazador.get_width()//2, 
                                        cazador_rect.centery - texto_cazador.get_height()//2))
        
        iniciar_rect = pygame.Rect(ANCHO_VENTANA//2 - 75, 350, 150, 50)
        color_iniciar = AZUL_ENEMIGO if self.nombre_input.strip() else GRIS
        pygame.draw.rect(self.ventana, color_iniciar, iniciar_rect)
        
        texto_iniciar = self.font.render("INICIAR", True, BLANCO)
        self.ventana.blit(texto_iniciar, (iniciar_rect.centerx - texto_iniciar.get_width()//2, 
                                        iniciar_rect.centery - texto_iniciar.get_height()//2))
        
        puntajes_rect = pygame.Rect(ANCHO_VENTANA//2 - 75, 420, 150, 40)
        pygame.draw.rect(self.ventana, MORADO_TUNEL, puntajes_rect)
        texto_puntajes = self.font_chica.render("VER PUNTAJES", True, BLANCO)
        self.ventana.blit(texto_puntajes, (puntajes_rect.centerx - texto_puntajes.get_width()//2, 
                                         puntajes_rect.centery - texto_puntajes.get_height()//2))
        
        return iniciar_rect, puntajes_rect, escape_rect, cazador_rect

    def manejar_eventos_registro(self):
        iniciar_rect, puntajes_rect, escape_rect, cazador_rect = self.mostrar_pantalla_registro()
        
        for evento in pygame.event.get():
            if evento.type == pygame.QUIT:
                self.corriendo = False
            
            elif evento.type == pygame.KEYDOWN:
                if evento.key == pygame.K_RETURN and self.nombre_input.strip():
                    # Detener m√∫sica del men√∫ e iniciar juego
                    self.juego.sonido.detener_musica()
                    self.juego.sonido.reproducir_efecto('movimiento')
                    self.juego.iniciar(self.nombre_input, self.modo_seleccionado)
                    self.estado = "jugando"
                
                elif evento.key == pygame.K_BACKSPACE:
                    self.nombre_input = self.nombre_input[:-1]
                
                elif evento.key == pygame.K_TAB:
                    self.modo_seleccionado = "CAZADOR" if self.modo_seleccionado == "ESCAPA" else "ESCAPA"
                    self.juego.sonido.reproducir_efecto('movimiento', volumen=0.3)

                elif evento.key == pygame.K_p:
                    self.mostrar_ventana_puntajes()
                
                else:
                    if len(self.nombre_input) < 20 and evento.unicode.isprintable():
                        self.nombre_input += evento.unicode
            
            elif evento.type == pygame.MOUSEBUTTONDOWN:
                if iniciar_rect.collidepoint(evento.pos) and self.nombre_input.strip():
                    self.juego.sonido.detener_musica()
                    self.juego.sonido.reproducir_efecto('movimiento')
                    self.juego.iniciar(self.nombre_input, self.modo_seleccionado)
                    self.estado = "jugando"
                
                elif puntajes_rect.collidepoint(evento.pos):
                    self.mostrar_ventana_puntajes()
                
                elif escape_rect.collidepoint(evento.pos):
                    self.modo_seleccionado = "ESCAPA"
                    self.juego.sonido.reproducir_efecto('movimiento', volumen=0.3)
                
                elif cazador_rect.collidepoint(evento.pos):
                    self.modo_seleccionado = "CAZADOR"
                    self.juego.sonido.reproducir_efecto('movimiento', volumen=0.3)

    def mostrar_ventana_puntajes(self):
        ventana_puntajes = VentanaPuntajes(self.ventana, self.juego.puntajes)
        ventana_puntajes.ejecutar()

    def dibujar_juego(self):
        # Dibujar mapa
        for x in range(self.juego.mapa.alto):
            for y in range(self.juego.mapa.ancho):
                casilla = self.juego.mapa.objetos[x][y]
                rect = pygame.Rect(y * TAMANO_CELDA, x * TAMANO_CELDA, TAMANO_CELDA, TAMANO_CELDA)
                
                if isinstance(casilla, Camino):
                    color = VERDE_CAMINO
                elif isinstance(casilla, Muro):
                    color = AZUL_MURO
                elif isinstance(casilla, Liana):
                    color = AMARILLO_LIANA
                elif isinstance(casilla, Tunel):
                    color = MORADO_TUNEL
                else:
                    color = NEGRO
                    
                pygame.draw.rect(self.ventana, color, rect)
                pygame.draw.rect(self.ventana, GRIS, rect, 1)
        
        # Dibujar trampas
        for trampa in self.juego.trampas:
            rect = pygame.Rect(trampa.y * TAMANO_CELDA, trampa.x * TAMANO_CELDA, TAMANO_CELDA, TAMANO_CELDA)
            pygame.draw.rect(self.ventana, NARANJA_TRAMPA, rect)
            pygame.draw.line(self.ventana, BLANCO, 
                           (trampa.y * TAMANO_CELDA, trampa.x * TAMANO_CELDA),
                           ((trampa.y + 1) * TAMANO_CELDA, (trampa.x + 1) * TAMANO_CELDA), 2)
            pygame.draw.line(self.ventana, BLANCO,
                           ((trampa.y + 1) * TAMANO_CELDA, trampa.x * TAMANO_CELDA),
                           (trampa.y * TAMANO_CELDA, (trampa.x + 1) * TAMANO_CELDA), 2)
        
        # Dibujar jugador
        jx, jy = self.juego.jugador.x, self.juego.jugador.y
        pygame.draw.rect(self.ventana, ROJO_JUGADOR, 
                        (jy * TAMANO_CELDA, jx * TAMANO_CELDA, TAMANO_CELDA, TAMANO_CELDA))
        
        # Dibujar enemigos
        for e in self.juego.enemigos:
            pygame.draw.rect(self.ventana, AZUL_ENEMIGO, 
                            (e.y * TAMANO_CELDA, e.x * TAMANO_CELDA, TAMANO_CELDA, TAMANO_CELDA))

    def dibujar_ui_juego(self):
        panel_rect = pygame.Rect(0, ALTO_MAPA * TAMANO_CELDA, ANCHO_VENTANA, 100)
        pygame.draw.rect(self.ventana, (50, 50, 50), panel_rect)

        if self.juego.modo_juego == "ESCAPA":
            modo_texto = "Coloca trampas con ESPACIO"
            modo_surface = self.font_chica.render(modo_texto, True, NARANJA_TRAMPA)
            self.ventana.blit(modo_surface, (ANCHO_VENTANA//2 - modo_surface.get_width()//2, ALTO_MAPA * TAMANO_CELDA + 10))

        info_texto = f"Jugador: {self.juego.nombre_jugador} | Modo: {self.juego.modo_juego}"
        info_surface = self.font_chica.render(info_texto, True, BLANCO)
        self.ventana.blit(info_surface, (10, ALTO_MAPA * TAMANO_CELDA + 40 if self.juego.modo_juego == "ESCAPA" else ALTO_MAPA * TAMANO_CELDA + 10))
        
        puntos_texto = f"Puntos: {self.juego.puntos}"
        puntos_surface = self.font_chica.render(puntos_texto, True, BLANCO)
        self.ventana.blit(puntos_surface, (10, ALTO_MAPA * TAMANO_CELDA + 15))
        
        if self.juego.modo_juego == "ESCAPA":
            tiempo_transcurrido = int(time.time() - self.juego.tiempo_inicio)
            tiempo_texto = f"Tiempo: {tiempo_transcurrido}s"
            tiempo_surface = self.font_chica.render(tiempo_texto, True, BLANCO)
            self.ventana.blit(tiempo_surface, (ANCHO_VENTANA - 150, ALTO_MAPA * TAMANO_CELDA + 10))
            
            trampas_texto = f"Trampas: {3 - len(self.juego.trampas)}/3"
            trampas_surface = self.font_chica.render(trampas_texto, True, BLANCO)
            self.ventana.blit(trampas_surface, (ANCHO_VENTANA//2 - 50, ALTO_MAPA * TAMANO_CELDA + 40))
            
            tiempo_actual = time.time()
            if tiempo_actual - self.juego.ultima_trampa_tiempo < 5:
                cooldown = 5 - (tiempo_actual - self.juego.ultima_trampa_tiempo)
                cooldown_texto = f"Trampa: {cooldown:.1f}s"
                cooldown_surface = self.font_chica.render(cooldown_texto, True, ROJO_ENERGIA)
                self.ventana.blit(cooldown_surface, (ANCHO_VENTANA//2 - 50, ALTO_MAPA * TAMANO_CELDA + 70))
        else:
            stats_texto = f"Atrapados: {self.juego.enemigos_atrapados}/10 | Escapados: {self.juego.enemigos_escapados}"
            stats_surface = self.font_chica.render(stats_texto, True, BLANCO)
            self.ventana.blit(stats_surface, (ANCHO_VENTANA - 300, ALTO_MAPA * TAMANO_CELDA + 10))

        energia_texto = f"Energ√≠a: {int(self.juego.jugador.energia)}/100"
        energia_surface = self.font_chica.render(energia_texto, True, BLANCO)
        self.ventana.blit(energia_surface, (ANCHO_VENTANA - 150, ALTO_MAPA * TAMANO_CELDA + 40))

        barra_rect = pygame.Rect(ANCHO_VENTANA - 150, ALTO_MAPA * TAMANO_CELDA + 70, 120, 15)
        pygame.draw.rect(self.ventana, GRIS, barra_rect)
        energia_ancho = int(120 * (self.juego.jugador.energia / 100))
        energia_color = VERDE_ENERGIA if self.juego.jugador.energia > 30 else ROJO_ENERGIA
        pygame.draw.rect(self.ventana, energia_color, (barra_rect.x, barra_rect.y, energia_ancho, barra_rect.height))

        if time.time() - self.tiempo_mensaje < 3 and self.mensaje_temporal:
            mensaje_surface = self.font_chica.render(self.mensaje_temporal, True, BLANCO)
            self.ventana.blit(mensaje_surface, (ANCHO_VENTANA//2 - mensaje_surface.get_width()//2, ALTO_MAPA * TAMANO_CELDA + 70))

    def manejar_eventos_juego(self):
        for evento in pygame.event.get():
            if evento.type == pygame.QUIT:
                self.corriendo = False
            
            elif evento.type == pygame.KEYDOWN:
                if evento.key == pygame.K_UP:
                    self.mover_jugador(-1, 0)
                elif evento.key == pygame.K_DOWN:
                    self.mover_jugador(1, 0)
                elif evento.key == pygame.K_LEFT:
                    self.mover_jugador(0, -1)
                elif evento.key == pygame.K_RIGHT:
                    self.mover_jugador(0, 1)
                elif evento.key == pygame.K_LSHIFT:
                    self.juego.jugador.corriendo = True
                elif evento.key == pygame.K_p:
                    self.mostrar_ventana_puntajes()
                elif evento.key == pygame.K_SPACE and self.juego.modo_juego == "ESCAPA":
                    exito, mensaje = self.juego.colocar_trampa()
                    self.mostrar_mensaje_temporal(mensaje)
                elif evento.key == pygame.K_ESCAPE:
                    self.estado = "registro"
                    self.nombre_input = ""
                    # Volver a reproducir m√∫sica del men√∫
                    self.juego.sonido.reproducir_musica('menu_principal', volumen=0.5)
            
            elif evento.type == pygame.KEYUP:
                if evento.key == pygame.K_LSHIFT:
                    self.juego.jugador.corriendo = False

    def mover_jugador(self, dx, dy):
        if self.juego.mover_jugador(dx, dy):
            self.verificar_estado_juego()

    def verificar_estado_juego(self):
        resultado, puntos = self.juego.verificar_estado_juego()
        if resultado != "continuar":
            self.estado = "game_over"
            self.resultado_final = resultado
            self.puntos_finales = puntos

    def mostrar_pantalla_game_over(self):
        self.ventana.fill(NEGRO)
        
        if self.resultado_final == "victoria":
            titulo = self.font.render("¬°VICTORIA!", True, VERDE_CAMINO)
            if self.juego.modo_juego == "ESCAPA":
                mensaje = f"{self.juego.nombre_jugador} ha escapado del laberinto!"
            else:
                mensaje = f"¬°Has atrapado a 10 enemigos!"
        else:
            titulo = self.font.render("GAME OVER", True, ROJO_JUGADOR)
            mensaje = f"{self.juego.nombre_jugador} fue atrapado!"
        
        self.ventana.blit(titulo, (ANCHO_VENTANA//2 - titulo.get_width()//2, 100))
        
        mensaje_surface = self.font_chica.render(mensaje, True, BLANCO)
        self.ventana.blit(mensaje_surface, (ANCHO_VENTANA//2 - mensaje_surface.get_width()//2, 180))
        
        puntos_texto = f"Puntos finales: {self.puntos_finales}"
        puntos_surface = self.font_chica.render(puntos_texto, True, BLANCO)
        self.ventana.blit(puntos_surface, (ANCHO_VENTANA//2 - puntos_surface.get_width()//2, 220))
        
        instrucciones = self.font_chica.render("Presiona R para jugar de nuevo o ESC para salir", True, BLANCO)
        self.ventana.blit(instrucciones, (ANCHO_VENTANA//2 - instrucciones.get_width()//2, 280))
        
        ver_puntajes = self.font_chica.render("Presiona P para ver los puntajes", True, BLANCO)
        self.ventana.blit(ver_puntajes, (ANCHO_VENTANA//2 - ver_puntajes.get_width()//2, 320))

    def manejar_eventos_game_over(self):
        for evento in pygame.event.get():
            if evento.type == pygame.QUIT:
                self.corriendo = False
            
            elif evento.type == pygame.KEYDOWN:
                if evento.key == pygame.K_r:
                    self.estado = "registro"
                    self.nombre_input = ""
                    # Reproducir m√∫sica del men√∫
                    self.juego.sonido.reproducir_musica('menu_principal', volumen=0.5)
                elif evento.key == pygame.K_ESCAPE:
                    self.corriendo = False
                elif evento.key == pygame.K_p:
                    self.mostrar_ventana_puntajes()

    def mostrar_mensaje_temporal(self, mensaje):
        self.mensaje_temporal = mensaje
        self.tiempo_mensaje = time.time()

    def ejecutar(self):
        while self.corriendo:
            tiempo_actual = pygame.time.get_ticks()
            
            if self.estado == "registro":
                self.manejar_eventos_registro()
            
            elif self.estado == "jugando":
                self.manejar_eventos_juego()
                
                # Actualizar enemigos peri√≥dicamente
                if tiempo_actual - self.juego.ultimo_movimiento_enemigos > self.juego.intervalo_movimiento:
                    self.juego.actualizar_enemigos()
                    self.juego.verificar_trampas()
                    self.juego.ultimo_movimiento_enemigos = tiempo_actual
                    self.verificar_estado_juego()
                
                # Actualizar energ√≠a
                self.juego.actualizar_energia()
                
                # Dibujar juego
                self.ventana.fill(NEGRO)
                self.dibujar_juego()
                self.dibujar_ui_juego()
            
            elif self.estado == "game_over":
                self.manejar_eventos_game_over()
                self.mostrar_pantalla_game_over()
            
            pygame.display.flip()
            self.reloj.tick(FPS)
        
        self.juego.sonido.detener_todo()
        pygame.quit()

# ================== EJECUCI√ìN ==================
if __name__ == "__main__":
    app = AppPygame()
    app.ejecutar()
