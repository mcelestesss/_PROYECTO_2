import pygame
import random
import time
import json
import os
from collections import deque
import math

# Inicialización de Pygame
pygame.init()

# Constantes del juego
ANCHO_MAPA = 21
ALTO_MAPA = 21
TAMANO_CELDA = 30
ANCHO_VENTANA = ANCHO_MAPA * TAMANO_CELDA
ALTO_VENTANA = ALTO_MAPA * TAMANO_CELDA + 100
FPS = 60

# Colores
NEGRO = (0, 0, 0)
BLANCO = (255, 255, 255)
GRIS = (128, 128, 128)
VERDE_CAMINO = (46, 204, 113)
AZUL_MURO = (52, 73, 94)
MORADO_TUNEL = (155, 89, 182)        # Túneles: morados (solo jugador)
AMARILLO_LIANA = (241, 196, 15)      # Lianas: amarillas (solo enemigos)
ROJO_JUGADOR = (231, 76, 60)
AZUL_ENEMIGO = (52, 152, 219)
VERDE_ENERGIA = (39, 174, 96)
ROJO_ENERGIA = (192, 57, 43)
NARANJA_TRAMPA = (230, 126, 34)     #Trampa


# Clases de Casillas (igual)
class Casilla:
    def _init_(self, x, y):
        self.x = x
        self.y = y
    def transitable_por_jugador(self): return False
    def transitable_por_enemigo(self): return False

class Camino(Casilla):
    def transitable_por_jugador(self): return True
    def transitable_por_enemigo(self): return True

class Muro(Casilla):
    def transitable_por_jugador(self): return False
    def transitable_por_enemigo(self): return False

class Liana(Casilla):
    def transitable_por_jugador(self): return False
    def transitable_por_enemigo(self): return True

class Tunel(Casilla):
    def transitable_por_jugador(self): return True
    def transitable_por_enemigo(self): return False


# Clase Mapa
# -------------------------------
class Mapa:
    def __init__(self, ancho, alto):
        self.ancho = ancho
        self.alto = alto
        self.matriz = [[1 for _ in range(ancho)] for _ in range(alto)]  # inicialmente muros
        self.objetos = None

    def generar_laberinto(self):
        # Función DFS recursiva para generar el laberinto
        def dfs(x, y):
            direcciones = [(2, 0), (-2, 0), (0, 2), (0, -2)]
            random.shuffle(direcciones)#IMPORTANTE EL SHUFFLE PARA RANDOMIZAR LOS MUROS Y EL LABERINTO 
            for dx, dy in direcciones:
                nx, ny = x + dx, y + dy
                if 1 <= nx < self.alto - 1 and 1 <= ny < self.ancho - 1:
                    if self.matriz[nx][ny] == 1:  # muro
                        self.matriz[nx][ny] = 0
                        self.matriz[x + dx // 2][y + dy // 2] = 0
                        dfs(nx, ny)
                        
        # Iniciar desde una posición y generar el laberinto
        # generar desde (1,1)
        self.matriz = [[1 for _ in range(self.ancho)] for _ in range(self.alto)]
        self.matriz[1][1] = 0
        dfs(1, 1)
        # Asegurar que la salida esté abierta
        self.matriz[self.alto - 2][self.ancho - 2] = 0

        self._agregar_elementos_especiales()#lianas y tuneles

    def _agregar_elementos_especiales(self):
        # Agregar algunas lianas (2) y túneles (3) aleatoriamente
        for _ in range(self.ancho * self.alto // 20):  # Aprox 5% del mapa
            x, y = random.randint(1, self.alto-2), random.randint(1, self.ancho-2)
            if self.matriz[x][y] == 0:  # Solo en caminos
                if random.random() < 0.5:
                    self.matriz[x][y] = 2  # Liana
                else:
                    self.matriz[x][y] = 3  # Túnel

    # BFS para validar que existe camino al final
    def existe_camino(self, inicio, fin): #usamos el bsf sea este qu epueda transitar si es enemigo o si es jugador
        queue = deque([inicio])
        visitado = set([inicio])
        while queue:
            x, y = queue.popleft()
            if (x, y) == fin: 
                return True
            for dx, dy in [(1, 0), (0, 1), (-1, 0), (0, -1)]:
                nx, ny = x + dx, y + dy
                if 0 <= nx < self.alto and 0 <= ny < self.ancho:
# revisar transitabilidad en base a matriz y tipo
                    if self.matriz[nx][ny] == 0 and (nx, ny) not in visitado:
                        visitado.add((nx, ny))
                        queue.append((nx, ny))
        return False

    def convertir_a_objetos(self):
        objetos = []
        for x in range(self.alto):
            fila = []
            for y in range(self.ancho):
                valor = self.matriz[x][y]
                if valor == 0: 
                    fila.append(Camino(x, y))
                elif valor == 1: 
                    fila.append(Muro(x, y))
                elif valor == 2: 
                    fila.append(Liana(x, y))
                elif valor == 3: 
                    fila.append(Tunel(x, y))
                else:
                    # Por defecto, muro si no reconoce el valor
                    fila.append(Muro(x, y))
            objetos.append(fila)
        self.objetos = objetos
        return objetos

    # Aux: comprobar transitabilidad directamente desde la matriz (útil antes de convertir)
    def _es_transitable_numero(self, x, y, es_jugador=True):
        v = self.matriz[x][y]
        if v == 0:  # camino
            return True
        if v == 1:  # muro
            return False
        if v == 2:  # liana -> solo enemigo
            return not es_jugador
        if v == 3:  # tunel -> solo jugador
            return es_jugador
        return False
    

# Clases de Entidades (igual)
class Entidad:
    def __init__(self, x, y):
        self.x = x
        self.y = y
        
    def mover(self, nx, ny):
        self.x = nx
        self.y = ny

class Jugador(Entidad):
    def __init__(self, x, y):
        super().__init__(x, y)
        self.energia = 100
        self.trampas = 3
        self.corriendo = False

class Enemigo(Entidad):
    def __init__(self, x, y):
        super().__init__(x, y)
        self.vivo = True

class Trampa:
    def _init_(self, x, y):
        self.x = x
        self.y = y
        self.tiempo_colocacion = time.time()
        self.activa = True
        self.tiempo_activacion = time.time()

    def verificar_tiempo_vida(self): 
        return time.time() - self.tiempo_activacion < 10    #duración trampa 10
 


# ================== SISTEMA DE SONIDO ==================
class SistemaSonido:
    def _init_(self):
        try:
            pygame.mixer.init(frequency=22050, size=-16, channels=2, buffer=512)
            self.sonidos = {}
            self.cargar_sonidos()
        except Exception as e:
            print(f"No se pudo inicializar el sistema de sonido - {e}")
            self.sonidos = None
    
    def cargar_sonidos(self):   #conecta a carpeta sonidos
        try:
            archivos_sonidos = {
                'inicio': 'inicio.wav',
                'movimiento': 'movimiento.wav', 
                'trampa': 'trampa.wav',
                'victoria': 'victoria.wav',
                'derrota': 'derrota.wav',
                'enemigo_atrapado': 'enemigo_atrapado.wav',
                'menu': 'menu.wav'
            }
            for nombre, archivo in archivos_sonidos.items():
                ruta = os.path.join('sonidos', archivo)
                if os.path.exists(ruta):
                    self.sonidos[nombre] = pygame.mixer.Sound(ruta)
                    print(f"Sonido cargado: {archivo}")
                else:           # exception
                    print(f"Archivo no encontrado: {ruta}, creando sonido temporal")
                    self.crear_sonido_temporal(nombre)                
        except Exception as e:
            print(f"Error cargando sonidos: {e}")       # Crea sonidos temporales si hay error
            self.crear_sonidos_temporales()
    
    def crear_sonido_temporal(self, nombre):
        """Crea un sonido simple temporal si no existe el archivo"""
        frecuencias = {
            'inicio': 523,      # Do
            'movimiento': 262,  # Do bajo
            'trampa': 330,      # Mi
            'victoria': 784,    # Sol
            'derrota': 196,     # Sol bajo
            'enemigo_atrapado': 392,  # Sol
            'menu': 440         # La
        }
        
        duraciones = {
            'inicio': 1000,
            'movimiento': 100,
            'trampa': 500, 
            'victoria': 1500,
            'derrota': 1000,
            'enemigo_atrapado': 300,
            'menu': 2000
        }
        
        freq = frecuencias.get(nombre, 440)
        duration = duraciones.get(nombre, 500)
        self.sonidos[nombre] = self.crear_sonido_simple(freq, duration)
    
    def crear_sonidos_temporales(self):
        self.sonidos = {
            'inicio': self.crear_sonido_simple(523, 1000),
            'movimiento': self.crear_sonido_simple(262, 100),
            'trampa': self.crear_sonido_simple(330, 500),
            'victoria': self.crear_sonido_simple(784, 1500),
            'derrota': self.crear_sonido_simple(196, 1000),
            'enemigo_atrapado': self.crear_sonido_simple(392, 300),
            'menu': self.crear_sonido_simple(440, 2000)
        }
    
    def crear_sonido_simple(self, frecuencia, duracion):
        try:
            sample_rate = 22050     #sonido basico con pygame
            frames = int(duracion * sample_rate / 1000.0)
            sound_bytes = bytearray()   #hacemso un arreglo o lista de bytes para le sonido como cuando ussbamos bitarray y esoss cods
            for i in range(frames):
                t = float(i) / sample_rate #hacemso uan onda simple para porbar
                val = int(127 + 127 * math.sin(2.0 * math.pi * frecuencia * t))
                sound_bytes.append(val)
            return pygame.mixer.Sound(bytes(sound_bytes))   #aca convertimos a sonido de pygame
        except Exception as e:
            print(f"Error creando sonido temporal: {e}")        # Si falla
            return pygame.mixer.Sound(buffer=bytes([128]*1000))
    
    def reproducir(self, nombre, volumen=1.0):
        if self.sonidos and nombre in self.sonidos:
            try:
                self.sonidos[nombre].set_volume(volumen)
                self.sonidos[nombre].play()
            except Exception as e:
                print(f"Error reproduciendo {nombre}: {e}")
    
    def detener(self, nombre):
        if self.sonidos and nombre in self.sonidos:
            try:
                self.sonidos[nombre].stop()
            except:
                pass
            
    def detener_todo(self):
        try:
            pygame.mixer.stop()
        except:
            pass


 #================== SISTEMA DE PUNTAJES ==============
class SistemaPuntajes:
    def __init__(self, archivo="puntajes.json"):
        self.archivo = archivo
        self.puntajes_escape = []
        self.puntajes_cazador = []
        self.cargar_puntajes()
    
    def cargar_puntajes(self):
        try:
            if os.path.exists(self.archivo):
                with open(self.archivo, 'r', encoding='utf-8') as f:
                    datos = json.load(f)
                    self.puntajes_escape = datos.get('escape', [])
                    self.puntajes_cazador = datos.get('cazador', [])
        except:
            self.puntajes_escape = []
            self.puntajes_cazador = []
    
    def guardar_puntajes(self):
        try:
            with open(self.archivo, 'w', encoding='utf-8') as f:
                json.dump({
                    'escape': self.puntajes_escape,
                    'cazador': self.puntajes_cazador
                }, f, indent=2, ensure_ascii=False)
        except:
            pass
    
    def agregar_puntaje(self, nombre, puntos, modo):
        if not nombre or not nombre.strip():
            nombre = "Jugador"
        
        nuevo_puntaje = {
            'nombre': nombre.strip(),
            'puntos': int(puntos),
            'fecha': time.strftime("%Y-%m-%d %H:%M:%S")
        }
        
        if modo == "ESCAPA":
            self.puntajes_escape.append(nuevo_puntaje)
            self.puntajes_escape.sort(key=lambda x: x['puntos'], reverse=True)
            self.puntajes_escape = self.puntajes_escape[:5]
        else:
            self.puntajes_cazador.append(nuevo_puntaje)
            self.puntajes_cazador.sort(key=lambda x: x['puntos'], reverse=True)
            self.puntajes_cazador = self.puntajes_cazador[:5]
        
        self.guardar_puntajes()
        return nuevo_puntaje
    
    def obtener_top_5(self, modo):
        return self.puntajes_escape if modo == "ESCAPA" else self.puntajes_cazador

    

# Clase Juego (Pygame)
class Juego:
    def __init__(self, ancho=ANCHO_MAPA, alto=ALTO_MAPA, num_enemigos=3):
        self.mapa = Mapa(ancho, alto)
        self.jugador = None
        self.enemigos = []
        self.trampas = []
        self.nombre_jugador = ""
        self.modo_juego = ""
        self.num_enemigos = num_enemigos
        
        # Sistema de puntuación
        self.puntos = 0
        self.tiempo_inicio = 0
        self.enemigos_atrapados = 0
        self.enemigos_escapados = 0
        self.ultima_trampa_tiempo = 0
        
        # Sistemas
        self.sonido = SistemaSonido()
        self.puntajes = SistemaPuntajes()
        self.juego_activo = False
        
        # Control de tiempo para enemigos
        self.ultimo_movimiento_enemigos = 0
        self.intervalo_movimiento = 500  # ms

    def reiniciar_estado(self):
        self.puntos = 0
        self.tiempo_inicio = 0
        self.enemigos_atrapados = 0
        self.enemigos_escapados = 0
        self.ultima_trampa_tiempo = 0
        self.trampas = []
        self.juego_activo = False
        self.ultimo_movimiento_enemigos = 0

    def iniciar(self, nombre, modo):
        self.reiniciar_estado()
        
        self.nombre_jugador = nombre.strip() if nombre.strip() else "Jugador"
        self.modo_juego = modo
        self.juego_activo = True
        self.tiempo_inicio = time.time()
        self.ultimo_movimiento_enemigos = pygame.time.get_ticks()

        self.sonido.reproducir('inicio', volumen=0.7)
        
        inicio = (1, 1)
        salida = (self.mapa.alto - 2, self.mapa.ancho - 2)
        
        # Generar laberinto válido
        self.mapa.generar_laberinto()
        while not self.mapa.existe_camino(inicio, salida):
            self.mapa.generar_laberinto()

        self.mapa.convertir_a_objetos()
        self.jugador = Jugador(*inicio)

        # Generar enemigos
        self.enemigos = []
        posibles = []
        for x in range(self.mapa.alto):
            for y in range(self.mapa.ancho):
                if self.mapa._es_transitable_numero(x, y, es_jugador=False):
                    if abs(x - inicio[0]) + abs(y - inicio[1]) > 6 and (x,y) != salida:
                        posibles.append((x,y))
        random.shuffle(posibles)
        
        i = 0
        while len(self.enemigos) < self.num_enemigos and i < len(posibles):
            pos = posibles[i]
            self.enemigos.append(Enemigo(*pos))
            i += 1
            
        if len(self.enemigos) == 0:
            self.enemigos.append(Enemigo(*salida))

    def actualizar_enemigos(self):
        if not self.juego_activo:
            return
            
        jugador_pos = (self.jugador.x, self.jugador.y)
        salida = (self.mapa.alto - 2, self.mapa.ancho - 2)

        for enemigo in self.enemigos:
            if (enemigo.x, enemigo.y) == jugador_pos:
                continue

            if self.modo_juego == "ESCAPA":
                # Enemigos persiguen al jugador
                inicio = (enemigo.x, enemigo.y)
                path = self.mapa.bfs_camino(inicio, jugador_pos, es_jugador=False)
                if path and len(path) >= 2:
                    siguiente = path[1]
                    enemigo.mover(*siguiente)
                else:
                    self._mover_enemigo_aleatorio(enemigo)
            else:
                # Enemigos huyen hacia la salida
                inicio = (enemigo.x, enemigo.y)
                path = self.mapa.bfs_camino(inicio, salida, es_jugador=False)
                if path and len(path) >= 2:
                    siguiente = path[1]
                    enemigo.mover(*siguiente)
                else:
                    self._mover_enemigo_aleatorio(enemigo)

    def _mover_enemigo_aleatorio(self, enemigo):
        opciones = []
        for dx, dy in [(1,0),(0,1),(-1,0),(0,-1)]:
            nx, ny = enemigo.x + dx, enemigo.y + dy
            if 0 <= nx < self.mapa.alto and 0 <= ny < self.mapa.ancho:
                if self.mapa._es_transitable_numero(nx, ny, es_jugador=False):
                    opciones.append((nx, ny))
        if opciones:
            enemigo.mover(*random.choice(opciones))

    def mover_jugador(self, dx, dy):
        if not self.juego_activo:
            return False
            
        nx = self.jugador.x + dx
        ny = self.jugador.y + dy
        
        if 0 <= nx < self.mapa.alto and 0 <= ny < self.mapa.ancho:
            casilla = self.mapa.objetos[nx][ny]
            if casilla.transitable_por_jugador():
                # Consumo de energía
                costo_energia = 2 if self.jugador.corriendo else 1
                if self.jugador.energia >= costo_energia:
                    self.jugador.energia -= costo_energia
                    self.jugador.mover(nx, ny)
                    self.sonido.reproducir('movimiento')
                    return True
        return False
    

    #SISTEMA DE TRAMPAS MEJORADO
    def colocar_trampa(self):
        """Coloca una trampa en modo ESCAPA - IMPLEMENTA TODAS LAS CONDICIONES"""
        if not self.juego_activo or self.modo_juego != "ESCAPA":
            return False, "Solo en modo ESCAPA"
            
        tiempo_actual = time.time()
        
        # Verificar límite de 3 trampas activas
        if len(self.trampas) >= 3:
            return False, "Máximo 3 trampas activas"
            
        # Verificar cooldown (5 segundos)
        if tiempo_actual - self.ultima_trampa_tiempo < 5:
            tiempo_restante = 5 - (tiempo_actual - self.ultima_trampa_tiempo)
            return False, f"Espera {tiempo_restante:.1f}s"
        
        # Colocar trampa
        nueva_trampa = Trampa(self.jugador.x, self.jugador.y)
        self.trampas.append(nueva_trampa)
        self.ultima_trampa_tiempo = tiempo_actual
        self.sonido.reproducir('trampa')
        return True, "Trampa colocada"

    def verificar_trampas(self):
        """Verifica si enemigos caen en trampas - CON BONO DE PUNTOS"""
        trampas_a_eliminar = []
        enemigos_a_eliminar = []
        
        for trampa in self.trampas:
            for enemigo in self.enemigos:
                if trampa.activa and trampa.x == enemigo.x and trampa.y == enemigo.y:
                    trampas_a_eliminar.append(trampa)
                    enemigos_a_eliminar.append(enemigo)
                    
                    # Bono de puntos por eliminar enemigo (25 puntos por enemigo)
                    bonus = 25
                    self.puntos += bonus
                    self.enemigos_atrapados += 1
                    self.sonido.reproducir('trampa')
                    break
        
        # Eliminar trampas y enemigos atrapados
        for trampa in trampas_a_eliminar:
            self.trampas.remove(trampa)
        
        for enemigo in enemigos_a_eliminar:
            self.enemigos.remove(enemigo)
            # Respawn después de 10 segundos
            self._programar_respawn(enemigo)
        
        return len(enemigos_a_eliminar) > 0

    def _programar_respawn(self, enemigo):
        """Programa el respawn de un enemigo después de 10 segundos"""
        # En una implementación completa usaríamos pygame.time.set_timer()
        # Por simplicidad, respawneamos inmediatamente en una posición aleatoria
        self._respawn_enemigo(enemigo)

    def _respawn_enemigo(self, enemigo):
        """Respawnea un enemigo en posición aleatoria"""
        opciones = []
        salida = (self.mapa.alto - 2, self.mapa.ancho - 2)
        
        for x in range(self.mapa.alto):
            for y in range(self.mapa.ancho):
                if self.mapa._es_transitable_numero(x, y, es_jugador=False):
                    if (x, y) != (self.jugador.x, self.jugador.y) and (x, y) != salida:
                        opciones.append((x, y))
        
        if opciones:
            nueva_pos = random.choice(opciones)
            enemigo.mover(nueva_pos[0], nueva_pos[1])
            self.enemigos.append(enemigo)

    def calcular_puntos_escape(self):
        tiempo_fin = time.time()
        tiempo_transcurrido = tiempo_fin - self.tiempo_inicio
        
        puntos_base = 1000
        penalizacion_tiempo = int(tiempo_transcurrido * 2)
        bonus_dificultad = self.num_enemigos * 50
        
        puntos_finales = max(100, puntos_base - penalizacion_tiempo + bonus_dificultad)
        self.puntos = puntos_finales
        
        # Guardar puntaje
        self.puntajes.agregar_puntaje(self.nombre_jugador, puntos_finales, "ESCAPA")
        self.sonido.reproducir('victoria')
        
        return puntos_finales

    def cazar_enemigo(self, enemigo):
        self.enemigos_atrapados += 1
        puntos_ganados = 20 * self.num_enemigos
        self.puntos += puntos_ganados
        
        self.sonido.reproducir('enemigo_atrapado')
        return puntos_ganados

    def enemigo_escapa(self, enemigo):
        self.enemigos_escapados += 1
        puntos_perdidos = 10 * self.num_enemigos
        self.puntos = max(0, self.puntos - puntos_perdidos)
        return puntos_perdidos

    def verificar_estado_juego(self):
        if not self.juego_activo:
            return "continuar", self.puntos
        salida = (self.mapa.alto - 2, self.mapa.ancho - 2)
        jugador_pos = (self.jugador.x, self.jugador.y)
        
        # MODO ESCAPA: Victoria al llegar a la salida
        if self.modo_juego == "ESCAPA" and jugador_pos == salida:
            puntos = self.calcular_puntos_escape()
            self.juego_activo = False
            return "victoria", puntos
        
        # MODO CAZADOR: Victoria al atrapar 10 enemigos
        elif self.modo_juego == "CAZADOR" and self.enemigos_atrapados >= 10:
            self.puntajes.agregar_puntaje(self.nombre_jugador, self.puntos, "CAZADOR")
            self.sonido.reproducir('victoria')
            self.juego_activo = False
            return "victoria", self.puntos
        
        # Verificar colisiones con enemigos
        for e in self.enemigos:
            if (e.x, e.y) == jugador_pos:
                if self.modo_juego == "ESCAPA":
                    # Derrota en modo ESCAPA
                    self.sonido.reproducir('derrota')
                    self.juego_activo = False
                    return "derrota", self.puntos
                elif self.modo_juego == "CAZADOR":
                    # Captura en modo CAZADOR
                    self.cazar_enemigo(e)
                    self._respawn_enemigo(e)
                    return "continuar", self.puntos
        
        # En modo CAZADOR, verificar si enemigos escapan
        if self.modo_juego == "CAZADOR":
            for e in self.enemigos:
                if (e.x, e.y) == salida:
                    self.enemigo_escapa(e)
                    self._respawn_enemigo(e)
        return "continuar", self.puntos

    def actualizar_energia(self):
        if self.juego_activo and self.jugador.energia < 100:
            self.jugador.energia = min(100, self.jugador.energia + 0.5)
# ================== INTERFAZ DE USUARIO ==================
class VentanaPuntajes:
    def _init_(self, pantalla, sistema_puntajes):
        self.pantalla = pantalla
        self.sistema_puntajes = sistema_puntajes
        self.font = pygame.font.Font(None, 36)
        self.font_chica = pygame.font.Font(None, 24)
        self.corriendo = True
    
    def ejecutar(self):
        while self.corriendo:
            for evento in pygame.event.get():
                if evento.type == pygame.QUIT:
                    self.corriendo = False
                elif evento.type == pygame.KEYDOWN:
                    if evento.key == pygame.K_ESCAPE or evento.key == pygame.K_RETURN:
                        self.corriendo = False
                elif evento.type == pygame.MOUSEBUTTONDOWN:
                    self.corriendo = False
            self.dibujar()
            pygame.display.flip()
    
    def dibujar(self):
        self.pantalla.fill(NEGRO)
        
        titulo = self.font.render("TOP 5 PUNTAJES", True, BLANCO)
        self.pantalla.blit(titulo, (ANCHO_VENTANA//2 - titulo.get_width()//2, 50))
        
        escape_titulo = self.font_chica.render("MODO ESCAPA", True, VERDE_CAMINO)
        self.pantalla.blit(escape_titulo, (100, 120))
        
        escape_puntajes = self.sistema_puntajes.obtener_top_5("ESCAPA")
        for i, puntaje in enumerate(escape_puntajes):
            texto = f"{i+1}. {puntaje['nombre']}: {puntaje['puntos']} pts"
            texto_surface = self.font_chica.render(texto, True, BLANCO)
            self.pantalla.blit(texto_surface, (100, 160 + i * 30))
        
        cazador_titulo = self.font_chica.render("MODO CAZADOR", True, ROJO_JUGADOR)
        self.pantalla.blit(cazador_titulo, (400, 120))
        
        cazador_puntajes = self.sistema_puntajes.obtener_top_5("CAZADOR")
        for i, puntaje in enumerate(cazador_puntajes):
            texto = f"{i+1}. {puntaje['nombre']}: {puntaje['puntos']} pts"
            texto_surface = self.font_chica.render(texto, True, BLANCO)
            self.pantalla.blit(texto_surface, (400, 160 + i * 30))
        
        instrucciones = self.font_chica.render("Presiona ESC, ENTER o haz clic para volver", True, BLANCO)
        self.pantalla.blit(instrucciones, (ANCHO_VENTANA//2 - instrucciones.get_width()//2, 350))


class AppPygame:
    def __init__(self):
        self.ventana = pygame.display.set_mode((ANCHO_VENTANA, ALTO_VENTANA))
        pygame.display.set_caption("Laberinto - POO")
        self.reloj = pygame.time.Clock()
        
        self.juego = Juego(ANCHO_MAPA, ALTO_MAPA, num_enemigos=4)
        
        self.corriendo = True
        self.estado = "registro"
        self.nombre_input = ""
        self.modo_seleccionado = "ESCAPA"
        
        self.font = pygame.font.Font(None, 36)
        self.font_chica = pygame.font.Font(None, 24)
        self.mensaje_temporal = ""
        self.tiempo_mensaje = 0

        #IMPORTANTOISIMO EL CONTROL DE LA MUSICA
        self.musica_reproduciendo = False
        self.reproducir_musica_menu()

    def mostrar_pantalla_registro(self):
        self.ventana.fill(NEGRO)
        
        titulo = self.font.render("REGISTRO DE JUGADOR", True, BLANCO)
        self.ventana.blit(titulo, (ANCHO_VENTANA//2 - titulo.get_width()//2, 50))
        
        texto_nombre = self.font_chica.render("Nombre del jugador:", True, BLANCO)
        self.ventana.blit(texto_nombre, (ANCHO_VENTANA//2 - 150, 150))
        
        input_rect = pygame.Rect(ANCHO_VENTANA//2 - 150, 180, 300, 40)
        pygame.draw.rect(self.ventana, BLANCO, input_rect, 2)
        
        nombre_texto = self.font_chica.render(self.nombre_input, True, BLANCO)
        self.ventana.blit(nombre_texto, (input_rect.x + 5, input_rect.y + 10))
        
        if int(time.time() * 2) % 2 == 0:
            cursor_x = input_rect.x + 5 + nombre_texto.get_width()
            pygame.draw.line(self.ventana, BLANCO, 
                           (cursor_x, input_rect.y + 5),
                           (cursor_x, input_rect.y + 35), 2)
        
        texto_modo = self.font_chica.render("Modo de juego:", True, BLANCO)
        self.ventana.blit(texto_modo, (ANCHO_VENTANA//2 - 150, 250))
        
        color_escape = VERDE_CAMINO if self.modo_seleccionado == "ESCAPA" else GRIS
        color_cazador = ROJO_JUGADOR if self.modo_seleccionado == "CAZADOR" else GRIS
        
        escape_rect = pygame.Rect(ANCHO_VENTANA//2 - 150, 290, 140, 40)
        cazador_rect = pygame.Rect(ANCHO_VENTANA//2 + 10, 290, 140, 40)
        
        pygame.draw.rect(self.ventana, color_escape, escape_rect)
        pygame.draw.rect(self.ventana, color_cazador, cazador_rect)
        
        texto_escape = self.font_chica.render("ESCAPA", True, BLANCO)
        texto_cazador = self.font_chica.render("CAZADOR", True, BLANCO)
        
        self.ventana.blit(texto_escape, (escape_rect.centerx - texto_escape.get_width()//2, 
                                       escape_rect.centery - texto_escape.get_height()//2))
        self.ventana.blit(texto_cazador, (cazador_rect.centerx - texto_cazador.get_width()//2, 
                                        cazador_rect.centery - texto_cazador.get_height()//2))
        
        iniciar_rect = pygame.Rect(ANCHO_VENTANA//2 - 75, 350, 150, 50)
        color_iniciar = AZUL_ENEMIGO if self.nombre_input.strip() else GRIS
        pygame.draw.rect(self.ventana, color_iniciar, iniciar_rect)
        
        texto_iniciar = self.font.render("INICIAR", True, BLANCO)
        self.ventana.blit(texto_iniciar, (iniciar_rect.centerx - texto_iniciar.get_width()//2, 
                                        iniciar_rect.centery - texto_iniciar.get_height()//2))
        
        puntajes_rect = pygame.Rect(ANCHO_VENTANA//2 - 75, 420, 150, 40)
        pygame.draw.rect(self.ventana, MORADO_TUNEL, puntajes_rect)
        texto_puntajes = self.font_chica.render("VER PUNTAJES", True, BLANCO)
        self.ventana.blit(texto_puntajes, (puntajes_rect.centerx - texto_puntajes.get_width()//2, 
                                         puntajes_rect.centery - texto_puntajes.get_height()//2))
        
        return iniciar_rect, puntajes_rect, escape_rect, cazador_rect



# ================== INTERFAZ DE USUARIO ==================
class VentanaPuntajes:
    def _init_(self, pantalla, sistema_puntajes):
        self.pantalla = pantalla
        self.sistema_puntajes = sistema_puntajes
        self.font = pygame.font.Font(None, 36)
        self.font_chica = pygame.font.Font(None, 24)
        self.corriendo = True
    
    def ejecutar(self):
        while self.corriendo:
            for evento in pygame.event.get():
                if evento.type == pygame.QUIT:
                    self.corriendo = False
                elif evento.type == pygame.KEYDOWN:
                    if evento.key == pygame.K_ESCAPE or evento.key == pygame.K_RETURN:
                        self.corriendo = False
                elif evento.type == pygame.MOUSEBUTTONDOWN:
                    self.corriendo = False
            self.dibujar()
            pygame.display.flip()
    
    def dibujar(self):
        self.pantalla.fill(NEGRO)
        
        titulo = self.font.render("TOP 5 PUNTAJES", True, BLANCO)
        self.pantalla.blit(titulo, (ANCHO_VENTANA//2 - titulo.get_width()//2, 50))
        
        escape_titulo = self.font_chica.render("MODO ESCAPA", True, VERDE_CAMINO)
        self.pantalla.blit(escape_titulo, (100, 120))
        
        escape_puntajes = self.sistema_puntajes.obtener_top_5("ESCAPA")
        for i, puntaje in enumerate(escape_puntajes):
            texto = f"{i+1}. {puntaje['nombre']}: {puntaje['puntos']} pts"
            texto_surface = self.font_chica.render(texto, True, BLANCO)
            self.pantalla.blit(texto_surface, (100, 160 + i * 30))
        
        cazador_titulo = self.font_chica.render("MODO CAZADOR", True, ROJO_JUGADOR)
        self.pantalla.blit(cazador_titulo, (400, 120))
        
        cazador_puntajes = self.sistema_puntajes.obtener_top_5("CAZADOR")
        for i, puntaje in enumerate(cazador_puntajes):
            texto = f"{i+1}. {puntaje['nombre']}: {puntaje['puntos']} pts"
            texto_surface = self.font_chica.render(texto, True, BLANCO)
            self.pantalla.blit(texto_surface, (400, 160 + i * 30))
        
        instrucciones = self.font_chica.render("Presiona ESC, ENTER o haz clic para volver", True, BLANCO)
        self.pantalla.blit(instrucciones, (ANCHO_VENTANA//2 - instrucciones.get_width()//2, 350))




class AppPygame:
    def __init__(self):
        self.ventana = pygame.display.set_mode((ANCHO_VENTANA, ALTO_VENTANA))
        pygame.display.set_caption("Laberinto - POO")
        self.reloj = pygame.time.Clock()
        
        self.juego = Juego(ANCHO_MAPA, ALTO_MAPA, num_enemigos=4)
        
        self.corriendo = True
        self.estado = "registro"
        self.nombre_input = ""
        self.modo_seleccionado = "ESCAPA"
        
        self.font = pygame.font.Font(None, 36)
        self.font_chica = pygame.font.Font(None, 24)
        self.mensaje_temporal = ""
        self.tiempo_mensaje = 0

        #IMPORTANTOISIMO EL CONTROL DE LA MUSICA
        self.musica_reproduciendo = False
        self.reproducir_musica_menu()

    def mostrar_pantalla_registro(self):
        self.ventana.fill(NEGRO)
        
        titulo = self.font.render("REGISTRO DE JUGADOR", True, BLANCO)
        self.ventana.blit(titulo, (ANCHO_VENTANA//2 - titulo.get_width()//2, 50))
        
        texto_nombre = self.font_chica.render("Nombre del jugador:", True, BLANCO)
        self.ventana.blit(texto_nombre, (ANCHO_VENTANA//2 - 150, 150))
        
        input_rect = pygame.Rect(ANCHO_VENTANA//2 - 150, 180, 300, 40)
        pygame.draw.rect(self.ventana, BLANCO, input_rect, 2)
        
        nombre_texto = self.font_chica.render(self.nombre_input, True, BLANCO)
        self.ventana.blit(nombre_texto, (input_rect.x + 5, input_rect.y + 10))
        
        if int(time.time() * 2) % 2 == 0:
            cursor_x = input_rect.x + 5 + nombre_texto.get_width()
            pygame.draw.line(self.ventana, BLANCO, 
                           (cursor_x, input_rect.y + 5),
                           (cursor_x, input_rect.y + 35), 2)
        
        texto_modo = self.font_chica.render("Modo de juego:", True, BLANCO)
        self.ventana.blit(texto_modo, (ANCHO_VENTANA//2 - 150, 250))
        
        color_escape = VERDE_CAMINO if self.modo_seleccionado == "ESCAPA" else GRIS
        color_cazador = ROJO_JUGADOR if self.modo_seleccionado == "CAZADOR" else GRIS
        
        escape_rect = pygame.Rect(ANCHO_VENTANA//2 - 150, 290, 140, 40)
        cazador_rect = pygame.Rect(ANCHO_VENTANA//2 + 10, 290, 140, 40)
        
        pygame.draw.rect(self.ventana, color_escape, escape_rect)
        pygame.draw.rect(self.ventana, color_cazador, cazador_rect)
        
        texto_escape = self.font_chica.render("ESCAPA", True, BLANCO)
        texto_cazador = self.font_chica.render("CAZADOR", True, BLANCO)
        
        self.ventana.blit(texto_escape, (escape_rect.centerx - texto_escape.get_width()//2, 
                                       escape_rect.centery - texto_escape.get_height()//2))
        self.ventana.blit(texto_cazador, (cazador_rect.centerx - texto_cazador.get_width()//2, 
                                        cazador_rect.centery - texto_cazador.get_height()//2))
        
        iniciar_rect = pygame.Rect(ANCHO_VENTANA//2 - 75, 350, 150, 50)
        color_iniciar = AZUL_ENEMIGO if self.nombre_input.strip() else GRIS
        pygame.draw.rect(self.ventana, color_iniciar, iniciar_rect)
        
        texto_iniciar = self.font.render("INICIAR", True, BLANCO)
        self.ventana.blit(texto_iniciar, (iniciar_rect.centerx - texto_iniciar.get_width()//2, 
                                        iniciar_rect.centery - texto_iniciar.get_height()//2))
        
        puntajes_rect = pygame.Rect(ANCHO_VENTANA//2 - 75, 420, 150, 40)
        pygame.draw.rect(self.ventana, MORADO_TUNEL, puntajes_rect)
        texto_puntajes = self.font_chica.render("VER PUNTAJES", True, BLANCO)
        self.ventana.blit(texto_puntajes, (puntajes_rect.centerx - texto_puntajes.get_width()//2, 
                                         puntajes_rect.centery - texto_puntajes.get_height()//2))
        
        return iniciar_rect, puntajes_rect, escape_rect, cazador_rect

    def manejar_eventos_registro(self):
        iniciar_rect, puntajes_rect, escape_rect, cazador_rect = self.mostrar_pantalla_registro()
        
        for evento in pygame.event.get():
            if evento.type == pygame.QUIT:
                self.corriendo = False
            
            elif evento.type == pygame.KEYDOWN:
                if evento.key == pygame.K_RETURN and self.nombre_input.strip():
                    self.detener_musica()#detenrlaal inciiciar juego 
                    self.juego.sonido.reproducir('inicio')#pornerl a del inicio 

                    if self.modo_seleccionado == "ESCAPA":
                        self.juego.sonido.reproducir('modo_escape', volumen=0.7)
                    else:   
                        self.juego.sonido.reproducir('modo_cazador', volumen=0.7)
                    self.juego.iniciar(self.nombre_input, self.modo_seleccionado)
                    self.estado = "jugando"
                
                elif evento.key == pygame.K_BACKSPACE:
                    self.nombre_input = self.nombre_input[:-1]
                
                elif evento.key == pygame.K_TAB:
                    self.modo_seleccionado = "CAZADOR" if self.modo_seleccionado == "ESCAPA" else "ESCAPA"
                    self.juego.sonido.reproducir('movimiento', volumen=0.3)


                elif evento.key == pygame.K_p:
                    self.mostrar_ventana_puntajes()
                
                else:
                    if len(self.nombre_input) < 20 and evento.unicode.isprintable():
                        self.nombre_input += evento.unicode
            
            elif evento.type == pygame.MOUSEBUTTONDOWN:
                if iniciar_rect.collidepoint(evento.pos) and self.nombre_input.strip():
                    self.detener_musica()#DETENER MÚSICA DEL MENÚ AL INICIAR JUEGO
                    self.juego.sonido.reproducir('inicio')

                    if self.modo_seleccionado == "ESCAPA":
                        self.juego.sonido.reproducir('modo_escape', volumen=0.7)
                    else:   
                        self.juego.sonido.reproducir('modo_cazador', volumen=0.7)

                    self.juego.iniciar(self.nombre_input, self.modo_seleccionado)
                    self.estado = "jugando"
                
                elif puntajes_rect.collidepoint(evento.pos):
                    self.mostrar_ventana_puntajes()
                
                elif escape_rect.collidepoint(evento.pos):
                    self.modo_seleccionado = "ESCAPA"
                    self.juego.sonido.reproducir('modo_escape', volumen=0.7)
                    self.juego.sonido.reproducir('modo_escape', volumen=0.7)  # Sonido de escapar
          
                
                elif cazador_rect.collidepoint(evento.pos):
                    self.modo_seleccionado = "CAZADOR"
                    self.juego.sonido.reproducir('movimiento', volumen=0.3)
                    self.juego.sonido.reproducir('modo_cazador', volumen=0.7)#Sonido pal cazador
    
    def mostrar_ventana_puntajes(self):
        ventana_puntajes = VentanaPuntajes(self.ventana, self.juego.puntajes)
        ventana_puntajes.ejecutar()
# Clase principal de la aplicación en Pygame


##########################
#ejecutar
##########################
