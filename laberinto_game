import pygame
import random
import time
import json
import os
from collections import deque
import math

# Inicialización de Pygame
pygame.init()

# Constantes del juego
ANCHO_MAPA = 21
ALTO_MAPA = 21
TAMANO_CELDA = 30
ANCHO_VENTANA = ANCHO_MAPA * TAMANO_CELDA
ALTO_VENTANA = ALTO_MAPA * TAMANO_CELDA + 100
FPS = 60

# Colores
NEGRO = (0, 0, 0)
BLANCO = (255, 255, 255)
GRIS = (128, 128, 128)
VERDE_CAMINO = (46, 204, 113)
AZUL_MURO = (52, 73, 94)
MORADO_TUNEL = (155, 89, 182)        # Túneles: morados (solo jugador)
AMARILLO_LIANA = (241, 196, 15)      # Lianas: amarillas (solo enemigos)
ROJO_JUGADOR = (231, 76, 60)
AZUL_ENEMIGO = (52, 152, 219)
VERDE_ENERGIA = (39, 174, 96)
ROJO_ENERGIA = (192, 57, 43)
NARANJA_TRAMPA = (230, 126, 34)     #Trampa


# Clases de Casillas (igual)
class Casilla:
    def _init_(self, x, y):
        self.x = x
        self.y = y
    def transitable_por_jugador(self): return False
    def transitable_por_enemigo(self): return False

class Camino(Casilla):
    def transitable_por_jugador(self): return True
    def transitable_por_enemigo(self): return True

class Muro(Casilla):
    def transitable_por_jugador(self): return False
    def transitable_por_enemigo(self): return False

class Liana(Casilla):
    def transitable_por_jugador(self): return False
    def transitable_por_enemigo(self): return True

class Tunel(Casilla):
    def transitable_por_jugador(self): return True
    def transitable_por_enemigo(self): return False


# Clase Mapa
# -------------------------------
class Mapa:
    def __init__(self, ancho, alto):
        self.ancho = ancho
        self.alto = alto
        self.matriz = [[1 for _ in range(ancho)] for _ in range(alto)]  # inicialmente muros
        self.objetos = None

    def generar_laberinto(self):
        # Función DFS recursiva para generar el laberinto
        def dfs(x, y):
            direcciones = [(2, 0), (-2, 0), (0, 2), (0, -2)]
            random.shuffle(direcciones)#IMPORTANTE EL SHUFFLE PARA RANDOMIZAR LOS MUROS Y EL LABERINTO 
            for dx, dy in direcciones:
                nx, ny = x + dx, y + dy
                if 1 <= nx < self.alto - 1 and 1 <= ny < self.ancho - 1:
                    if self.matriz[nx][ny] == 1:  # muro
                        self.matriz[nx][ny] = 0
                        self.matriz[x + dx // 2][y + dy // 2] = 0
                        dfs(nx, ny)
                        
        # Iniciar desde una posición y generar el laberinto
        # generar desde (1,1)
        self.matriz = [[1 for _ in range(self.ancho)] for _ in range(self.alto)]
        self.matriz[1][1] = 0
        dfs(1, 1)
        # Asegurar que la salida esté abierta
        self.matriz[self.alto - 2][self.ancho - 2] = 0

        self._agregar_elementos_especiales()#lianas y tuneles

    def _agregar_elementos_especiales(self):
        # Agregar algunas lianas (2) y túneles (3) aleatoriamente
        for _ in range(self.ancho * self.alto // 20):  # Aprox 5% del mapa
            x, y = random.randint(1, self.alto-2), random.randint(1, self.ancho-2)
            if self.matriz[x][y] == 0:  # Solo en caminos
                if random.random() < 0.5:
                    self.matriz[x][y] = 2  # Liana
                else:
                    self.matriz[x][y] = 3  # Túnel

    # BFS para validar que existe camino al final
    def existe_camino(self, inicio, fin): #usamos el bsf sea este qu epueda transitar si es enemigo o si es jugador
        queue = deque([inicio])
        visitado = set([inicio])
        while queue:
            x, y = queue.popleft()
            if (x, y) == fin: 
                return True
            for dx, dy in [(1, 0), (0, 1), (-1, 0), (0, -1)]:
                nx, ny = x + dx, y + dy
                if 0 <= nx < self.alto and 0 <= ny < self.ancho:
# revisar transitabilidad en base a matriz y tipo
                    if self.matriz[nx][ny] == 0 and (nx, ny) not in visitado:
                        visitado.add((nx, ny))
                        queue.append((nx, ny))
        return False

    def convertir_a_objetos(self):
        objetos = []
        for x in range(self.alto):
            fila = []
            for y in range(self.ancho):
                valor = self.matriz[x][y]
                if valor == 0: 
                    fila.append(Camino(x, y))
                elif valor == 1: 
                    fila.append(Muro(x, y))
                elif valor == 2: 
                    fila.append(Liana(x, y))
                elif valor == 3: 
                    fila.append(Tunel(x, y))
                else:
                    # Por defecto, muro si no reconoce el valor
                    fila.append(Muro(x, y))
            objetos.append(fila)
        self.objetos = objetos
        return objetos

    # Aux: comprobar transitabilidad directamente desde la matriz (útil antes de convertir)
    def _es_transitable_numero(self, x, y, es_jugador=True):
        v = self.matriz[x][y]
        if v == 0:  # camino
            return True
        if v == 1:  # muro
            return False
        if v == 2:  # liana -> solo enemigo
            return not es_jugador
        if v == 3:  # tunel -> solo jugador
            return es_jugador
        return False
    

# Clases de Entidades (igual)
class Entidad:
    def __init__(self, x, y):
        self.x = x
        self.y = y
        
    def mover(self, nx, ny):
        self.x = nx
        self.y = ny

class Jugador(Entidad):
    def __init__(self, x, y):
        super().__init__(x, y)
        self.energia = 100
        self.trampas = 3
        self.corriendo = False

class Enemigo(Entidad):
    def __init__(self, x, y):
        super().__init__(x, y)
        self.vivo = True

class Trampa:
    def _init_(self, x, y):
        self.x = x
        self.y = y
        self.tiempo_colocacion = time.time()
        self.activa = True
        self.tiempo_activacion = time.time()

    def verificar_tiempo_vida(self): 
        return time.time() - self.tiempo_activacion < 10    #duración trampa 10
 


# ================== SISTEMA DE SONIDO ==================
class SistemaSonido:
    def _init_(self):
        try:
            pygame.mixer.init(frequency=22050, size=-16, channels=2, buffer=512)
            self.sonidos = {}
            self.cargar_sonidos()
        except Exception as e:
            print(f"No se pudo inicializar el sistema de sonido - {e}")
            self.sonidos = None
    
    def cargar_sonidos(self):   #conecta a carpeta sonidos
        try:
            archivos_sonidos = {
                'inicio': 'inicio.wav',
                'movimiento': 'movimiento.wav', 
                'trampa': 'trampa.wav',
                'victoria': 'victoria.wav',
                'derrota': 'derrota.wav',
                'enemigo_atrapado': 'enemigo_atrapado.wav',
                'menu': 'menu.wav'
            }
            for nombre, archivo in archivos_sonidos.items():
                ruta = os.path.join('sonidos', archivo)
                if os.path.exists(ruta):
                    self.sonidos[nombre] = pygame.mixer.Sound(ruta)
                    print(f"Sonido cargado: {archivo}")
                else:           # exception
                    print(f"Archivo no encontrado: {ruta}, creando sonido temporal")
                    self.crear_sonido_temporal(nombre)                
        except Exception as e:
            print(f"Error cargando sonidos: {e}")       # Crea sonidos temporales si hay error
            self.crear_sonidos_temporales()
    
    def crear_sonido_temporal(self, nombre):
        """Crea un sonido simple temporal si no existe el archivo"""
        frecuencias = {
            'inicio': 523,      # Do
            'movimiento': 262,  # Do bajo
            'trampa': 330,      # Mi
            'victoria': 784,    # Sol
            'derrota': 196,     # Sol bajo
            'enemigo_atrapado': 392,  # Sol
            'menu': 440         # La
        }
        
        duraciones = {
            'inicio': 1000,
            'movimiento': 100,
            'trampa': 500, 
            'victoria': 1500,
            'derrota': 1000,
            'enemigo_atrapado': 300,
            'menu': 2000
        }
        
        freq = frecuencias.get(nombre, 440)
        duration = duraciones.get(nombre, 500)
        self.sonidos[nombre] = self.crear_sonido_simple(freq, duration)
    
    def crear_sonidos_temporales(self):
        self.sonidos = {
            'inicio': self.crear_sonido_simple(523, 1000),
            'movimiento': self.crear_sonido_simple(262, 100),
            'trampa': self.crear_sonido_simple(330, 500),
            'victoria': self.crear_sonido_simple(784, 1500),
            'derrota': self.crear_sonido_simple(196, 1000),
            'enemigo_atrapado': self.crear_sonido_simple(392, 300),
            'menu': self.crear_sonido_simple(440, 2000)
        }
    
    def crear_sonido_simple(self, frecuencia, duracion):
        try:
            sample_rate = 22050     #sonido basico con pygame
            frames = int(duracion * sample_rate / 1000.0)
            sound_bytes = bytearray()   #hacemso un arreglo o lista de bytes para le sonido como cuando ussbamos bitarray y esoss cods
            for i in range(frames):
                t = float(i) / sample_rate #hacemso uan onda simple para porbar
                val = int(127 + 127 * math.sin(2.0 * math.pi * frecuencia * t))
                sound_bytes.append(val)
            return pygame.mixer.Sound(bytes(sound_bytes))   #aca convertimos a sonido de pygame
        except Exception as e:
            print(f"Error creando sonido temporal: {e}")        # Si falla
            return pygame.mixer.Sound(buffer=bytes([128]*1000))
    
    def reproducir(self, nombre, volumen=1.0):
        if self.sonidos and nombre in self.sonidos:
            try:
                self.sonidos[nombre].set_volume(volumen)
                self.sonidos[nombre].play()
            except Exception as e:
                print(f"Error reproduciendo {nombre}: {e}")
    
    def detener(self, nombre):
        if self.sonidos and nombre in self.sonidos:
            try:
                self.sonidos[nombre].stop()
            except:
                pass
            
    def detener_todo(self):
        try:
            pygame.mixer.stop()
        except:
            pass


 #================== SISTEMA DE PUNTAJES ==============
class SistemaPuntajes:
    def __init__(self, archivo="puntajes.json"):
        self.archivo = archivo
        self.puntajes_escape = []
        self.puntajes_cazador = []
        self.cargar_puntajes()
    
    def cargar_puntajes(self):
        try:
            if os.path.exists(self.archivo):
                with open(self.archivo, 'r', encoding='utf-8') as f:
                    datos = json.load(f)
                    self.puntajes_escape = datos.get('escape', [])
                    self.puntajes_cazador = datos.get('cazador', [])
        except:
            self.puntajes_escape = []
            self.puntajes_cazador = []
    
    def guardar_puntajes(self):
        try:
            with open(self.archivo, 'w', encoding='utf-8') as f:
                json.dump({
                    'escape': self.puntajes_escape,
                    'cazador': self.puntajes_cazador
                }, f, indent=2, ensure_ascii=False)
        except:
            pass
    
    def agregar_puntaje(self, nombre, puntos, modo):
        if not nombre or not nombre.strip():
            nombre = "Jugador"
        
        nuevo_puntaje = {
            'nombre': nombre.strip(),
            'puntos': int(puntos),
            'fecha': time.strftime("%Y-%m-%d %H:%M:%S")
        }
        
        if modo == "ESCAPA":
            self.puntajes_escape.append(nuevo_puntaje)
            self.puntajes_escape.sort(key=lambda x: x['puntos'], reverse=True)
            self.puntajes_escape = self.puntajes_escape[:5]
        else:
            self.puntajes_cazador.append(nuevo_puntaje)
            self.puntajes_cazador.sort(key=lambda x: x['puntos'], reverse=True)
            self.puntajes_cazador = self.puntajes_cazador[:5]
        
        self.guardar_puntajes()
        return nuevo_puntaje
    
    def obtener_top_5(self, modo):
        return self.puntajes_escape if modo == "ESCAPA" else self.puntajes_cazador

    

# Clase Juego (Pygame)

# Clase principal de la aplicación en Pygame

#lo que falta

##########################
#ejecutar
##########################
